# -*- coding: utf-8 -*-
"""CW5_Syamsulhakim

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11du-hbkeDl0USiuC-mz6oCKyI6K_P5EP
"""

# cw5_full_complete.py
# Complete staffing MILP for Java & Co.
# - Baseline
# - Scenario A (close @19:00)
# - Scenario B (PT min 16)
# - Fairness variant (Hmax - Hmin, <=102% baseline)
# - Skills variant (infeasible -> relaxed)
# - Wage sensitivity (+10% / -10%)
# - Unavailable-barista sensitivity (example)
# - Human-readable day/block names and CSV outputs
#
# Requirements: pulp
# Run: python cw5_full_complete.py

import pulp as pl
import csv
import os

# ---------- Readable labels ----------
DAY_NAME = {1: "Mon", 2: "Tue", 3: "Wed", 4: "Thu", 5: "Fri", 6: "Sat", 7: "Sun"}
BLOCK_NAME = {
    1: "07:00–11:00",
    2: "11:00–15:00",
    3: "15:00–19:00",
    4: "19:00–23:00"
}

# ---------- Problem data (from assignment brief) ----------
H = 4  # hours per block

baristas = ["Max", "Jiwa", "Fore", "Donna", "Paul"]
# Employment type: P = part-time, F = full-time
etype = {"Max": "P", "Jiwa": "P", "Fore": "P", "Donna": "F", "Paul": "F"}

# Hourly cost (IDR)
cost_default = {"Max": 50000, "Jiwa": 50000, "Fore": 50000, "Donna": 150000, "Paul": 150000}

# Daily availability table (hours) Mon=1 ... Sun=7
avail_default = {
    "Max":  {1:8, 2:8, 3:8, 4:0, 5:8, 6:4, 7:4},
    "Jiwa": {1:4, 2:4, 3:8, 4:8, 5:0, 6:4, 7:0},
    "Fore": {1:8, 2:0,  3:8, 4:8, 5:8, 6:8, 7:0},
    "Donna":{1:12,2:12,3:12,4:12,5:12,6:12,7:8},
    "Paul": {1:12,2:8, 3:12,4:12,5:8, 6:12,7:12},
}

# Weekly minimums (hours)
minWeekly_default = {o: (12 if etype[o] == "P" else 36) for o in baristas}

# Days and blocks
days = list(range(1, 8))   # 1..7 (Mon..Sun)
blocks = list(range(1, 5)) # 1..4 (each block = 4 hours)

# Output directory for CSVs
RESULTS_DIR = "results"
if not os.path.exists(RESULTS_DIR):
    os.makedirs(RESULTS_DIR)


# ---------- Core model builder and helpers ----------
def build_staffing_model(cost, avail, minWeekly, allow_blocks=None, name="StaffingModel"):
    """
    Build and return (model, y_vars, allow_blocks_used)
    y_vars is a dict keyed by (o,d,b) -> pulp variable
    allow_blocks: optional dict day -> iterable of allowed block indices
    """
    if allow_blocks is None:
        allow_blocks = {d: set(blocks) for d in days}
    else:
        allow_blocks = {d: set(allow_blocks.get(d, [])) for d in days}

    model = pl.LpProblem(name, pl.LpMinimize)

    # Decision variables
    y = {}
    for o in baristas:
        for d in days:
            for b in allow_blocks[d]:
                y[(o, d, b)] = pl.LpVariable(f"y_{o}_{d}_{b}", cat="Binary")

    # Objective: minimize total weekly wage cost
    model += pl.lpSum(H * cost[o] * y[(o, d, b)]
                      for o in baristas for d in days for b in allow_blocks[d]), "TotalWeeklyWageCost"

    # Coverage: at least one barista per block/day
    for d in days:
        for b in allow_blocks[d]:
            model += pl.lpSum(y[(o, d, b)] for o in baristas) >= 1, f"Coverage_d{d}_b{b}"

    # Per-day availability (hours)
    for o in baristas:
        for d in days:
            allowed_bs = allow_blocks[d]
            if allowed_bs:
                model += H * pl.lpSum(y[(o, d, b)] for b in allowed_bs) <= avail[o][d], f"Avail_{o}_d{d}"

    # Contractual daily block limits
    for o in baristas:
        daily_limit = 2 if etype[o] == "P" else 3
        for d in days:
            allowed_bs = allow_blocks[d]
            if allowed_bs:
                model += pl.lpSum(y[(o, d, b)] for b in allowed_bs) <= daily_limit, f"DailyCap_{o}_d{d}"

    # Weekly minimum hours
    for o in baristas:
        model += H * pl.lpSum(y[(o, d, b)] for d in days for b in allow_blocks[d]) >= minWeekly[o], f"WeeklyMin_{o}"

    return model, y, allow_blocks


def extract_results(model, y_vars, allow_blocks, cost):
    """
    After solving, extract solver status, monetary cost, weekly hours per barista, and schedule mapping.
    """
    status = pl.LpStatus[model.status]
    hours = {o: 0 for o in baristas}
    schedule = {d: {b: [] for b in allow_blocks[d]} for d in days}

    for o in baristas:
        for d in days:
            for b in allow_blocks[d]:
                var = y_vars.get((o, d, b))
                if var is None:
                    continue
                val = pl.value(var)
                if val is None:
                    val = 0
                if round(val) >= 1:
                    schedule[d][b].append(o)
                    hours[o] += H

    total_cost = sum(hours[o] * cost[o] for o in baristas)
    return status, int(total_cost), hours, schedule


def print_summary(title, status, total_cost, hours, schedule, allow_blocks=None):
    if allow_blocks is None:
        allow_blocks = {d: set(blocks) for d in days}
    print("\n" + "="*80)
    print(title)
    print(f"Solver status: {status}")
    print(f"Total weekly cost (IDR): {total_cost:,}")
    print("Weekly hours per barista:")
    for o in baristas:
        print(f"  {o:6s}: {hours[o]} hrs")
    print("\nDaily schedule (DayName: BlockTime -> assigned):")
    for d in days:
        day_label = DAY_NAME.get(d, f"Day{d}")
        print(f"{day_label}:")
        for b in sorted(allow_blocks[d]):
            block_label = BLOCK_NAME.get(b, f"Block{b}")
            assigned = schedule[d].get(b, [])
            print(f"  {block_label}: {', '.join(assigned) if assigned else '[empty]'}")
    print("="*80 + "\n")


def save_schedule_csv(filename, hours, schedule, allow_blocks=None):
    if allow_blocks is None:
        allow_blocks = {d: set(blocks) for d in days}
    filepath = os.path.join(RESULTS_DIR, filename)
    with open(filepath, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Day", "DayName", "Block", "BlockTime", "Assigned"])
        for d in days:
            for b in sorted(allow_blocks[d]):
                assigned = schedule[d].get(b, [])
                writer.writerow([
                    d,
                    DAY_NAME.get(d, f"Day{d}"),
                    b,
                    BLOCK_NAME.get(b, f"Block{b}"),
                    ";".join(assigned)
                ])
    hours_file = filepath.replace(".csv", "_hours.csv")
    with open(hours_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Barista", "WeeklyHours"])
        for o in baristas:
            writer.writerow([o, hours[o]])
    return filepath, hours_file


# ---------- Scenario and solver wrapper functions ----------
def solve_baseline(cost=cost_default, avail=avail_default, minWeekly=minWeekly_default):
    model, y_vars, allow_blocks = build_staffing_model(cost, avail, minWeekly, name="Baseline")
    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_vars, allow_blocks, cost)
    return model, (status, total_cost, hours, schedule), allow_blocks


def solve_close_at_19(cost=cost_default, avail=avail_default, minWeekly=minWeekly_default):
    allow_blocks = {d: {1, 2, 3} for d in days}
    model, y_vars, allow_blocks_built = build_staffing_model(cost, avail, minWeekly, allow_blocks=allow_blocks, name="CloseAt19")
    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_vars, allow_blocks_built, cost)
    return model, (status, total_cost, hours, schedule), allow_blocks_built


def solve_pt_min16(cost=cost_default, avail=avail_default, minWeekly=minWeekly_default):
    minWeekly_mod = {o: (16 if etype[o] == "P" else minWeekly[o]) for o in baristas}
    model, y_vars, allow_blocks = build_staffing_model(cost, avail, minWeekly_mod, name="PTmin16")
    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_vars, allow_blocks, cost)
    return model, (status, total_cost, hours, schedule), allow_blocks


def solve_fairness(baseline_cost, cost=cost_default, avail=avail_default, minWeekly=minWeekly_default, time_limit=600):
    """
    Fairness model: minimize (Hmax - Hmin) subject to coverage and weekly minima
    and budget constraint: total_cost <= 1.02 * baseline_cost
    """
    model, y_vars, allow_blocks = build_staffing_model(cost, avail, minWeekly, name="Fairness")
    # Introduce Hmax and Hmin (continuous >= 0)
    Hmax = pl.LpVariable("Hmax", lowBound=0, cat="Continuous")
    Hmin = pl.LpVariable("Hmin", lowBound=0, cat="Continuous")

    # Link Hmax/Hmin with weekly hours of each barista
    for o in baristas:
        weekly_sum = H * pl.lpSum(y_vars[(o, d, b)] for d in days for b in allow_blocks[d])
        model += weekly_sum <= Hmax, f"Hmax_link_{o}"
        model += weekly_sum >= Hmin, f"Hmin_link_{o}"

    # Budget constraint: actual weekly monetary cost ≤ 1.02 * baseline_cost
    total_weekly_cost_expr = pl.lpSum(H * cost[o] * y_vars[(o, d, b)] for o in baristas for d in days for b in allow_blocks[d])
    model += total_weekly_cost_expr <= 1.02 * baseline_cost, "budget_cap_102pct"

    # New objective: minimize Hmax - Hmin
    model += Hmax - Hmin, "MinimizeInequity"

    solver = pl.PULP_CBC_CMD(msg=True, timeLimit=time_limit)
    model.solve(solver)

    status = pl.LpStatus[model.status]
    _, _, hours, schedule = extract_results(model, y_vars, allow_blocks, cost)
    actual_monetary_cost = sum(hours[o] * cost[o] for o in baristas)
    try:
        fairness_gap = pl.value(Hmax) - pl.value(Hmin)
    except Exception:
        fairness_gap = None

    return model, (status, fairness_gap, actual_monetary_cost, hours, schedule), allow_blocks

def solve_skills_variant_infeasible(cost=cost_default, avail=avail_default, minWeekly=minWeekly_default):
    """
    Intentionally infeasible skills constraint:
    Require BOTH Max and Jiwa to be present in every block on Sat(6) & Sun(7).
    """
    allow_blocks = {d: set(blocks) for d in days}
    model, y_vars, allow_blocks = build_staffing_model(cost, avail, minWeekly, allow_blocks=allow_blocks, name="Skills_Infeasible")

    # Infeasible constraint: both Max and Jiwa must be present every block on Sat & Sun
    for d in [6, 7]:
        for b in allow_blocks[d]:
            model += pl.lpSum(y_vars[(o, d, b)] for o in ["Max", "Jiwa"]) >= 2, f"skill_both_parttimers_d{d}_b{b}"

    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_vars, allow_blocks, cost)
    return model, (status, total_cost, hours, schedule), allow_blocks


def solve_skills_variant_relaxed(cost=cost_default, avail=avail_default, minWeekly=minWeekly_default):
    """
    Relaxed (feasible) skills constraint:
    Require AT LEAST ONE of Max or Jiwa in every block on Sat & Sun.
    """
    allow_blocks = {d: set(blocks) for d in days}
    model, y_vars, allow_blocks = build_staffing_model(cost, avail, minWeekly, allow_blocks=allow_blocks, name="Skills_Relaxed")

    # Relaxed constraint: at least one of Max or Jiwa per block on Sat & Sun
    for d in [6, 7]:
        for b in allow_blocks[d]:
            model += pl.lpSum(y_vars[(o, d, b)] for o in ["Max", "Jiwa"]) >= 1, f"skill_atleast_one_parttimer_d{d}_b{b}"

    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_vars, allow_blocks, cost)
    return model, (status, total_cost, hours, schedule), allow_blocks

def solve_wage_sensitivity(multiplier, avail=avail_default, minWeekly=minWeekly_default):
    cost_new = {o: int(round(cost_default[o] * multiplier)) for o in baristas}
    model, y_res, allow_blocks = build_staffing_model(cost_new, avail, minWeekly, name=f"WageSens_{multiplier}")
    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_res, allow_blocks, cost_new)
    return model, (status, total_cost, hours, schedule), allow_blocks, cost_new


def solve_unavailable_barista(barista_unavail, day_unavail, cost=cost_default, avail=avail_default, minWeekly=minWeekly_default):
    avail_mod = {o: dict(avail[o]) for o in baristas}
    if barista_unavail not in avail_mod:
        raise ValueError("Unknown barista")
    avail_mod[barista_unavail][day_unavail] = 0
    model, y_res, allow_blocks = build_staffing_model(cost, avail_mod, minWeekly, name=f"Unavailable_{barista_unavail}_d{day_unavail}")
    solver = pl.PULP_CBC_CMD(msg=True)
    model.solve(solver)
    status, total_cost, hours, schedule = extract_results(model, y_res, allow_blocks, cost)
    return model, (status, total_cost, hours, schedule), allow_blocks

# ---------- Main runner ----------
def main():
    # Baseline
    print("Running baseline model...")
    baseline_model, (status_base, base_cost, base_hours, base_schedule), allow_blocks_base = solve_baseline()
    print_summary("BASELINE MODEL", status_base, base_cost, base_hours, base_schedule, allow_blocks=allow_blocks_base)
    save_schedule_csv("baseline_schedule.csv", base_hours, base_schedule, allow_blocks=allow_blocks_base)

    # Scenario A: close at 19:00 (blocks 1-3)
    print("Running Scenario A: close at 19:00 (blocks 1-3 only)...")
    sA_model, (status_sA, sA_cost, sA_hours, sA_schedule), allow_blocks_sA = solve_close_at_19()
    print_summary("SCENARIO A — CLOSE AT 19:00 (remove block 4)", status_sA, sA_cost, sA_hours, sA_schedule, allow_blocks=allow_blocks_sA)
    save_schedule_csv("close19_schedule.csv", sA_hours, sA_schedule, allow_blocks=allow_blocks_sA)

    # Scenario B: part-time minimum 16 hours/week
    print("Running Scenario B: increase part-time weekly min 12 -> 16...")
    sB_model, (status_sB, sB_cost, sB_hours, sB_schedule), allow_blocks_sB = solve_pt_min16()
    print_summary("SCENARIO B — PART-TIME MIN = 16 HOURS", status_sB, sB_cost, sB_hours, sB_schedule, allow_blocks=allow_blocks_sB)
    save_schedule_csv("ptmin16_schedule.csv", sB_hours, sB_schedule, allow_blocks=allow_blocks_sB)

    # Fairness variant
    print("Running Fairness variant (minimize Hmax - Hmin) with budget ≤ 102% of baseline ...")
    fairness_model, (status_fair, fairness_gap, fair_monetary_cost, fair_hours, fair_schedule), allow_blocks_fair = solve_fairness(base_cost, time_limit=600)
    print("\nFAIRNESS MODEL RESULTS")
    print(f"Solver status: {status_fair}")
    print(f"Fairness gap (Hmax - Hmin) in hours: {fairness_gap}")
    print(f"Actual monetary cost under fairness (IDR): {fair_monetary_cost:,}")
    print_summary("FAIRNESS SCHEDULE", status_fair, fair_monetary_cost, fair_hours, fair_schedule, allow_blocks=allow_blocks_fair)
    save_schedule_csv("fairness_schedule.csv", fair_hours, fair_schedule, allow_blocks=allow_blocks_fair)

    # Skills Variant
    print("Running Skills Variant (infeasible version: require BOTH Max and Jiwa on Sat & Sun)...")
    sk_inf_model, (status_sk_inf, sk_inf_cost, sk_inf_hours, sk_inf_schedule), allow_blocks_sk_inf = solve_skills_variant_infeasible()
    print_summary("SKILLS VARIANT (INFEASIBLE) - Require BOTH Max & Jiwa on Sat/Sun", status_sk_inf, sk_inf_cost, sk_inf_hours, sk_inf_schedule, allow_blocks=allow_blocks_sk_inf)
    save_schedule_csv("skills_infeasible_schedule.csv", sk_inf_hours, sk_inf_schedule, allow_blocks=allow_blocks_sk_inf)

    print("Running Skills Variant (relaxed version: require AT LEAST ONE of Max/Jiwa on Sat & Sun)...")
    sk_rel_model, (status_sk_rel, sk_rel_cost, sk_rel_hours, sk_rel_schedule), allow_blocks_sk_rel = solve_skills_variant_relaxed()
    print_summary("SKILLS VARIANT (RELAXED) - Require AT LEAST ONE of Max/Jiwa on Sat/Sun", status_sk_rel, sk_rel_cost, sk_rel_hours, sk_rel_schedule, allow_blocks=allow_blocks_sk_rel)
    save_schedule_csv("skills_relaxed_schedule.csv", sk_rel_hours, sk_rel_schedule, allow_blocks=allow_blocks_sk_rel)

    # Wage sensitivity: +10% and -10%
    print("Running wage sensitivity: +10% ...")
    wplus_model, (status_wplus, wplus_cost, wplus_hours, wplus_schedule), allow_blocks_wplus, cost_wplus = solve_wage_sensitivity(1.10)
    print_summary("WAGE SENSITIVITY: +10%", status_wplus, wplus_cost, wplus_hours, wplus_schedule, allow_blocks=allow_blocks_wplus)
    save_schedule_csv("wage_plus10_schedule.csv", wplus_hours, wplus_schedule, allow_blocks=allow_blocks_wplus)

    print("Running wage sensitivity: -10% ...")
    wminus_model, (status_wminus, wminus_cost, wminus_hours, wminus_schedule), allow_blocks_wminus, cost_wminus = solve_wage_sensitivity(0.90)
    print_summary("WAGE SENSITIVITY: -10%", status_wminus, wminus_cost, wminus_hours, wminus_schedule, allow_blocks=allow_blocks_wminus)
    save_schedule_csv("wage_minus10_schedule.csv", wminus_hours, wminus_schedule, allow_blocks=allow_blocks_wminus)

    # Barista-unavailable example: Donna unavailable on day 3 (Wed)
    test_barista = "Donna"
    test_day = 3
    print(f"Running unavailable-barista sensitivity: {test_barista} unavailable on day {test_day} ...")
    un_model, (status_un, un_cost, un_hours, un_schedule), allow_blocks_un = solve_unavailable_barista(test_barista, test_day)
    print_summary(f"UNAVAILABLE: {test_barista} DAY {test_day}", status_un, un_cost, un_hours, un_schedule, allow_blocks=allow_blocks_un)
    save_schedule_csv(f"{test_barista}_no_day{test_day}_schedule.csv", un_hours, un_schedule, allow_blocks=allow_blocks_un)

    # Summary of key costs
    print("Summary of key costs (IDR):")
    print(f"  Baseline cost: {base_cost:,}")
    print(f"  Scenario A (close@19): {sA_cost:,}")
    print(f"  Scenario B (PT min=16): {sB_cost:,}")
    print(f"  Fairness schedule cost: {fair_monetary_cost:,}")
    print(f"  Wage +10% cost: {wplus_cost:,}")
    print(f"  Wage -10% cost: {wminus_cost:,}")
    print(f"  {test_barista} unavailable day {test_day} cost: {un_cost:,}")
    print(f"  Skills infeasible status: {status_sk_inf}, reported cost field: {sk_inf_cost:,}")
    print(f"  Skills relaxed cost: {sk_rel_cost:,}")

    # Save a summary CSV
    summary_file = os.path.join(RESULTS_DIR, "summary_costs.csv")
    with open(summary_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Scenario", "SolverStatus", "WeeklyCostIDR"])
        writer.writerow(["Baseline", status_base, base_cost])
        writer.writerow(["Close@19", status_sA, sA_cost])
        writer.writerow(["PTmin16", status_sB, sB_cost])
        writer.writerow(["Fairness", status_fair, fair_monetary_cost])
        writer.writerow(["Skills_Infeasible", status_sk_inf, sk_inf_cost])
        writer.writerow(["Skills_Relaxed", status_sk_rel, sk_rel_cost])
        writer.writerow(["Wage+10%", status_wplus, wplus_cost])
        writer.writerow(["Wage-10%", status_wminus, wminus_cost])
        writer.writerow([f"{test_barista}_unavailable_d{test_day}", status_un, un_cost])

    print(f"All CSV outputs saved in '{RESULTS_DIR}' directory.")


if __name__ == "__main__":
    main()